<!--
 * @Auther: zth
 * @Date: 2024-03-08 23:11:51
 * @LastEditTime: 2024-03-09 22:45:30
 * @Description:
-->

# 思路篇

> 参考博客：[东哥带你刷二叉树（思路篇）](https://labuladong.online/algo/data-structure/binary-tree-part1/)

二叉树解题的思维模式分两类：

1. 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。
2. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

- 如果单独抽出一个二叉树节点，它需要做什么事情？
- 需要在什么时候（前/中/后序位置）做？
- 其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

# 构造篇

> 参考博客：[东哥带你刷二叉树（构造篇）](https://labuladong.online/algo/data-structure/binary-tree-part2/)

- 二叉树的构造问题一般都是使用「分解问题」的思路：
  - 构造整棵树 = 根节点 + 构造左子树 + 构造右子树。
  - 先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。

# 后序篇

> 参考博客：[东哥带你刷二叉树（后序篇）](https://labuladong.online/algo/data-structure/binary-tree-part3/)

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

那么换句话说，一旦你发现题目和**子树**有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

# 序列化篇

> 参考博客：[东哥带你刷二叉树（序列化篇）](https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/)

1. 如果你的序列化结果中**不包含空指针**的信息，且你只给出**一种**遍历顺序，那么你无法还原出唯一的一棵二叉树。
2. 如果你的序列化结果中**不包含空指针**的信息，且你会给出**两种**遍历顺序，那么按照前文 东哥手把手带你刷二叉树（构造篇） 所说，分两种情况：

   2.1. 如果你给出的是**前序和中序**，或者**后序和中序**，那么你可以还原出唯一的一棵二叉树。

   2.2. 如果你给出~~前序和后序~~，那么你无法还原出唯一的一棵二叉树。

3. 如果你的序列化结果中**包含空指针**的信息，且你只给出**一种**遍历顺序，也要分两种情况：

   3.1. 如果你给出的是**前序**或者**后序**，那么你可以还原出唯一的一棵二叉树。

   3.2. 如果你给出的是~~中序~~，那么你无法还原出唯一的一棵二叉树。
